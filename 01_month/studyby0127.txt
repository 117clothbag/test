进程和线程：
进程是程序的一次执行，是运行在自己的虚拟地址空间的一个具有独立功能的程序，进程是分配和释放资源的基本单位，当程序执行时，系统创建进程，进程结束时，系统回收这些资源
线程又名轻负荷进程，它是在进程基础上的一次执行，一个进程可以拥有多个线程，线程没有独立的资源，它共享进程的ID。共享进程的资源，线城市UNXI中最小的调度单位。目前有系统级调度和进程调度两种线程调度实行方式：系统级调度的操作系统一级线程为单位进行调度，进程级调度的操作系统仍以进程为单位进行调度，进程再为其上运行的线程提供调度控制

僵尸进程：
所有进程都会进入的一个进程状态，子进程退出，而父进程没有调用wait()或waitpid()获取子进程的状态信息，那么子进程的pid和进程描述符等资源仍然保存在系统中
危害：如果进程不调用wait或waitpid的话，那么保留的那段信息就不会释放，其进程号就一直被占用，但是系统所能用的进程号是有限的，如果产生大量的僵尸进程，将因为没有可用的进程号未导致系统不能产生新的进程
孤儿进程：
一个父进程退出，而他的一个或多个子进程还在运行，那这些子进程就是孤儿进程

解决僵尸进程的方法：
#方法一，传递信号给其父进程，命令其回收子进程的资源
kill -CHLD + 父进程号

#方法二，直接kill掉父进程，将此进程变为孤儿进程，交给init进程管理，init进程回收此进程的资源
kill -9 + 父进程号

linux获取环境变量的方法：
unix系统中采用一个指针数组来存储全部环境变量值：
#include <stdio.h>

extern char **environ;

int main()
{
	char **p = environ;
	while(*p) {
		printf(stderr, "%s\n", *p);
		p++;
	}
	return 0;
}

在进程中执行新程序的三种方法：
fork 创建新进程
exec 执行新进程
sleep 休眠进程
wait 同步进程
exit 结束进程

#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
fork函数的特点：在父进程中调用一次，在父进程和子进程中各返回一次，子进程中fork的返回值是0，而父进程中的fork返回的是子进程的pid。
fork在子进程中返回0，子进程仍可以调用getpid函数得到自己的进程id，也可以调用getppid函数得到父进程的id。在父进程通过fork的返回子得到子进程id

pid_t pid;
pid = fork()
if(pid < 0) {
	perror("fork faild");
} 
if(pid == 0) {
	"子进程"
} else {
	"父进程"
}

【fread函数和read函数的区别】
1.fread 函数是封装好的库函数，而read函数是系统函数，一般来说，fread效率更高
2.读取文件的差别：fread函数功能更强大，可以读取结构体的二进制文件，但是如果是最底层的操作，用到文件描述符的话，用read会更好

char *strerror(int errnum);
errnum --错误号，通常是errno
该函数返回一个指向错误字符串的指针，该错误字符串描述了错误
实例： strerror(errno);

【进程通信】
1.管道通信
#include <unistd.h>
int pipe(int fd[2]);
fd[0]为读而打开，fd[1]为写打开
要关闭管道只需要将这两个文件描述符关闭即可

2.管道通信【FIFO命名管道】
FIFO可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，他以一种特殊设备文件形式存在于文件系统
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
其中mode参与open函数的mode相同。一旦创建了一个FIFO，就可以用一般的文件I/O函数操作它

3.消息队列
消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级
消息队列独立于发送与接收进程。进程终止时，消息队列及其内容不会被删除
消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取
#include <sys/msg.h>
int msgget(key_t key, int flag);  创建或打开消息队列：成功返回队列ID，失败返回-1
int msgsnd(int msqid, const void*ptr, size_t size, int flag);  添加消息：成功返回0，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type, int flag);  读取消息：成功返回消息数据的长度，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);  控制消息队列：成功返回0，失败返回-1

4.信号量
信号量与其他进程通信(IPC)结构不一样，它是一个计数器。信号量用于实现进程间的互斥和同步，而不是 用于存储进程间的通信数据
信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作
每次对信号量值加一或减一，而且可以加减任意正整数。支持信号量组

5.共享内存
共享内存，指两个或多个进程共享一个特定的存储区
共享内存是最快的一种IPC，因为进程是直接对内存进行存取
因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问








